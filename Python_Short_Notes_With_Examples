# Python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
import pandas as pd
import numpy as np

# Case-sensitivity: Except True, False and None, all keywords are in lowercare.

# Single Comment

""" Multiline string comments 
But they can be used as a multi-line comment as well.
Docstrings appear right after the definition of a function, method, class, or module.
"""
def tripple(num):
    """Here goes docstring... Function to triple the value"""
    return num * 3

# A code block starts with indentation (generally 4 spaces) and ends with the first unindented line. 

# Assign variables
x, y, z = 1, 2.5, "love"
print(x, y, z)

# A constant is a type of variable whose value cannot be changed

# Declare and assign them on the main.py or or create a file, say const.py and refer to it in main.py
g = 981
x = const.g

# Literal is a raw data given in a variable or constant. Types: Numeric. String, Boolian. Special.

# 4 different literal collections. List, Tuple, Set and Dict.
my_list  = [1, 2.5, 'love']              # list
my_tuple = (1, 2.5, 'love')              # tuple
my_set   = {1, 2.5, 'love'}              # set
my_dict  = {'x':1, 'y':2.5, 'z':'love'}  # dictionary

# Everything is an object. Data types are classes. Variables are instance (object) of classes.

# Which class does a variable or values belong to? Use type().
# How to check if an object belongs to a particular class? Use isinstance().
type(my_list)
type(my_list[1])
isinstance(my_list, list)
isinstance(my_list[1], float)

# Type conversion. 
# Implicit. Auto converts lower to higher data type to avoid data loss. Ex integer to float.
# Explicit. But in other cases, it needs explicit conversion. Also called Type Conversion.
num_str = '123'
num_int = int(num_str)

# Accept input
num = input('Enter a number: ', )

# Arithmetic Operators
+ - * / 
% (modulus) 
// (floor division)
** exponent

# Comparison Operators
<  >  == != >= <=

# Logical Operators
and
or
not

# Bitwise Operator
& is AND
| is OR
- is NOT
^ is XOR
>> is RIGHT SHIFT
<< is LEFT SHIFT

# Asignment Operator
= += -+ *= /+ etc

# Special Operators : Identity
is
is not

# Special Operators : Membership
in     not in

# Namespace

# Flow Control - if else

if <test condition> :
    do this
elif <test condition> :
    do this
else:
    do this
   
def sign_of_a_num(x):
    if (x > 0):
        print ('x is positive ', x)
    elif (x < 0):
        print ('x is negative ', x)
    else:
        print ('x is zero ', x)
        
sign_of_a_num (5)
sign_of_a_num (-11)
sign_of_a_num (0)

# Flow Control - for loop
my_list = [0.1.2.3.4]
sum = 0
for x in my_list:
    sum = sum + x
print (sum)

# Functions - range arange
range(10)
range(0,10)
list(range(0,10)
range(3,10)
range(2,10,3)
list(range(2,10,3))

arange(3*5).reshapce(3,5)
arange(3*5).reshapce(5,3)

# Flow Control - for loop with elsenum = list(range(0,5))
num = list(range(0,10))
for i in num:
    print(i)
else:
    print('end of num list... no more num to print')

# Flow Control - while loop and while loop with else
num = list(range(0,10))
i = 0
while (i < 5):
    print(i)
    i = i + 1
else:
    print('came out of while condition...')


        print ('x

# Flow Control - break, continue, pass
num = list(range(0,10))
for i in num:
    if (i < 3):
        print('hit continue since counter value is ', i)
        continue
    if (i == 8):
        print('now loop will break since counter value is ', i)
        break
    print('*** printing counter since it is ', i)
print('finally, came out of loop')

num = list(range(0,10))
for i in num:
    pass
print('hit a pass, so nothing to do here, came out of loop')

""" Datatypes ...
begin here...

Number
String
List
Tuple
Set
Dictionaty
"""

# Datatypes 1 : Number - int, float, complex

int(-2.3)          # output -2
float(5)           # output 5.0
complex('1+2j')    # output 1+2j
complex(1+2j)      # output 1+2j

# Datatypes 1 :  Number - Decimal
1.1 + 2.2 == 3.3 turn out to be False

import decimal as dc
print(dc.Decimal(0.1)) 
# or equivalently
from decimal import Decimal as D
print(D(0.1))    # output 0.1000000000000000055511151231257827021181583404541015625

from decimal import Decimal as D
print( D('1.1') + D('2.2') )    # output 3.3
# use decimal over flot when we want to control level of precisions, ex. financial calc etc

# Datatypes 1 :  Number - Fraction
from fractions import Fraction as F
print ( F(1.5))
 
# Datatypes 1 : Number - Python Math

import math
math.cos(math.pi/3)      # 0.5...
math.tan(math.pi/4)      # 0.9999.... ( = 1 ) 
math.exp(1)              # 2.718...
math.log(math.exp(1))    # 1.0
math.log10(100)          # 2.0
math.factorial(4)        # 120


# Datatypes 1 : Number -  Function - random
import random
random.randrange(1,1000)
random.randint(1,1000)
random.random()       # get a random number

x = list(range(0,10))
random.choise(x)      # random element from list is chosen
random.shuffle(x)     # the list x is shuffled and ordered randomly
print(x)              # see it happens


# Datatypes 2 : String

